#include <bits/stdc++.h>

using namespace std;


typedef long long ll;
typedef vector<ll> vi;
typedef pair<ll, ll> ii;
typedef vector<ii> vii;

// ref: https://stackoverflow.com/questions/23556249/continued-fractions
ii contToFrac(vi a, int size) {
    ll n = 1;
    ll d = a[size - 1];
    for (int i = size - 2; i >= 0; i--) {
        int nextd = d * a[i] + n;
        n = d;
        d = nextd;
    }
    return ii(d, n);
}

vi fracToCont(ii frac) {
    vi a;
    ll n = frac.first;
    ll d = frac.second;
    while (d != 0) { // d = 0 means n is divisible by d
        a.push_back(n / d);
        n = n % d;
        swap(n, d);
    }
    return a;
}

ii fracAdd(ii a, ii b) {
    return ii(a.first * b.second + a.second * b.first, a.second * b.second);
}

ii fracSubtract(ii a, ii b) {
    return ii(a.first * b.second - a.second * b.first, a.second * b.second);
}

ii fracMultiply(ii a, ii b) {
    return ii(a.first * b.first, a.second * b.second);
}

ii fracDivide(ii a, ii b) {
    return ii(a.first * b.second, a.second * b.first);
}

void changeFracToContAndPrint(ii frac) {
    vi a = fracToCont(frac);
    while (a.size() > 1 && a.back() == 0) a.pop_back();
    for (int i = 0; i < a.size(); i++) {
        if (i < a.size() - 1) cout << a[i] << " ";
        else cout << a[i] << '\n';
    }
}

// NOTE ABOVE typedef i lazily replaced int into long long...

int main() {
    //freopen("input.txt", "r", stdin);
    //freopen("output.txt", "w", stdout);
    //freopen("error.txt", "w", stderr);

    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n1, n2;
    cin >> n1 >> n2;
    vi a(n1), b(n2);
    for (int i = 0; i < n1; i++) {
        cin >> a[i];
    }
    for (int i = 0; i < n2; i++) {
        cin >> b[i];
    }
    ii frac1 = contToFrac(a, n1);
    ii frac2 = contToFrac(b, n2);
    // add
    ii frac = fracAdd(frac1, frac2);
    changeFracToContAndPrint(frac);
    // subtract
    frac = fracSubtract(frac1, frac2);
    changeFracToContAndPrint(frac);
    // multiply
    frac = fracMultiply(frac1, frac2);
    changeFracToContAndPrint(frac);
    // divide
    frac = fracDivide(frac1, frac2);
    changeFracToContAndPrint(frac);

    cerr << "time taken : " << (float) clock() / CLOCKS_PER_SEC << " secs" << '\n';
    return 0;
}


//// generated by copilot
//struct fraction {
//    ll num, den;
//    fraction(ll num = 0, ll den = 1) : num(num), den(den) {
//        ll g = __gcd(num, den);
//        num /= g;
//        den /= g;
//        if (den < 0) {
//            num = -num;
//            den = -den;
//        }
//    }
//    fraction reduce() const {
//        ll g = __gcd(num, den);
//        return {num / g, den / g};
//    }
//    fraction operator+(const fraction &f) const {
//        return {num * f.den + f.num * den, den * f.den};
//    }
//    fraction operator-(const fraction &f) const {
//        return {num * f.den - f.num * den, den * f.den};
//    }
//    fraction operator*(const fraction &f) const {
//        return {num * f.num, den * f.den};
//    }
//    fraction operator/(const fraction &f) const {
//        return {num * f.den, den * f.num};
//    }
//    bool operator<(const fraction &f) const {
//        return num * f.den < f.num * den;
//    }
//    bool operator==(const fraction &f) const {
//        return num * f.den == f.num * den;
//    }
//    bool operator>(const fraction &f) const {
//        return num * f.den > f.num * den;
//    }
//    bool operator<=(const fraction &f) const {
//        return num * f.den <= f.num * den;
//    }
//    bool operator>=(const fraction &f) const {
//        return num * f.den >= f.num * den;
//    }
//    friend ostream &operator<<(ostream &os, const fraction &f) {
//        os << f.num;
//        if (f.den != 1) {
//            os << "/" << f.den;
//        }
//        return os;
//    }
//};