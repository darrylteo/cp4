#include <bits/stdc++.h>

using namespace std;

#define big 1000000000000000

typedef long long ll;
typedef long double ld;

// generated by copilot
struct fraction {
    ll num, den;

    fraction(ll num = 0, ll den = 1) : num(num), den(den) {
        ll g = __gcd(num, den);
        num /= g;
        den /= g;
        if (den < 0) {
            num = -num;
            den = -den;
        }
    }

    fraction reduce() const {
        ll g = __gcd(num, den);
        ll tmpNum = num / g;
        ll tmpDen = den / g;
        if (tmpDen < 0) {
            tmpNum = -tmpNum;
            tmpDen = -tmpDen;
        }
        return {tmpNum, tmpDen};
    }

    fraction operator+(const fraction &f) const {
        return {num * f.den + f.num * den, den * f.den};
    }

    fraction operator-(const fraction &f) const {
        return {num * f.den - f.num * den, den * f.den};
    }

    fraction operator*(const fraction &f) const {
        return {num * f.num, den * f.den};
    }

    fraction operator/(const fraction &f) const {
        return {num * f.den, den * f.num};
    }

    bool operator<(const fraction &f) const {
        return num * f.den < f.num * den;
    }

    bool operator==(const fraction &f) const {
        return num * f.den == f.num * den;
    }

    bool operator>(const fraction &f) const {
        return num * f.den > f.num * den;
    }

    bool operator<=(const fraction &f) const {
        return num * f.den <= f.num * den;
    }

    bool operator>=(const fraction &f) const {
        return num * f.den >= f.num * den;
    }

    friend ostream &operator<<(ostream &os, const fraction &f) {
        os << f.num;
        if (f.den != 1) {
            os << "/" << f.den;
        }
        return os;
    }
};

const int MAX_N = 2;                             // adjust as needed
struct AugmentedMatrix {
    fraction mat[MAX_N][MAX_N + 1];
};
struct ColumnVector {
    fraction vec[MAX_N];
};

ColumnVector GaussianElimination(int N, AugmentedMatrix Aug) {
    // check if any eqn is invalid
    for (int i = 0; i < N; ++i) {
        bool valid = false;
        for (int j = 0; j < N; ++j) {
            if (Aug.mat[i][j].num != 0) {
                valid = true;
                break;
            }
        }
        if (!valid && Aug.mat[i][N].num != 0) {
            ColumnVector Ans;
            Ans.vec[0].num = big;
            Ans.vec[0].den = big;
            Ans.vec[1].num = big;
            Ans.vec[1].den = big;
            return Ans;
        }
    }
    // check linearly dependent
    bool dep = true;
    for (int i = 0; i < 3; ++i) {
        if ((Aug.mat[0][i].num == 0) != (Aug.mat[1][i].num == 0)) {
            dep = false; // 1 has number 1 doesn't, sure not dependent
            break;
        }
    }
    if (dep) { // maybe dependent
        vector<fraction> ratios;
        for (int i = 0; i < 3; ++i) {
            if (Aug.mat[0][i].num != 0) {
                ratios.push_back(Aug.mat[1][i] / Aug.mat[0][i]);
            }
        }
        bool same = true;
        for (int i = 1; i < ratios.size(); ++i) {
            if (ratios[i] != ratios[i - 1]) {
                same = false;
                break;
            }
        }
        if (same && ratios.size() == 3) {
            ColumnVector Ans;
            Ans.vec[0].num = big;
            Ans.vec[0].den = big;
            Ans.vec[1].num = big;
            Ans.vec[1].den = big;
            return Ans;
        }
    }
    // check if any equation has only 1 variable, then we can solve directly
    for (int i = 0; i < N; ++i) { // which eqn
        int eqn[2] = {0, 0};
        for (int j = 0; j < N; ++j) { // which variable
            if (Aug.mat[i][j].num != 0) eqn[j] = 1;
        }
        if (eqn[0] + eqn[1] == 1) {
            int varIdx = eqn[0] == 1 ? 0 : 1;
            int varIdxOther = eqn[0] == 1 ? 1 : 0;
            int eqnIdx = i;
            int eqnIdxOther = !i;
            ColumnVector Ans;
            Ans.vec[varIdx] = Aug.mat[i][N] / Aug.mat[i][varIdx];
            // sub this to other eqn
            if (Aug.mat[eqnIdxOther][varIdxOther] == 0) {
                Ans.vec[varIdxOther].num = big;
                Ans.vec[varIdxOther].den = big;
                // check if consistent with first eqn too
                if (Aug.mat[eqnIdxOther][varIdx] * Ans.vec[varIdx] != Aug.mat[eqnIdxOther][N]) {
                    Ans.vec[varIdx].num = big;
                    Ans.vec[varIdx].den = big;
                }
            } else {
                Ans.vec[varIdxOther] = (Aug.mat[eqnIdxOther][N] - Aug.mat[eqnIdxOther][varIdx] * Ans.vec[varIdx]) /
                                       Aug.mat[eqnIdxOther][varIdxOther];
            }
            return Ans;
        }
    }


    // normal case
    // input: N, Augmented Matrix Aug, output: Column vector X, the answer
    for (int i = 0; i < N - 1; ++i) {                // forward elimination
        for (int j = i + 1; j < N; ++j) {               // actual fwd elimination
            for (int k = N; k >= i; --k) {
                if (Aug.mat[i][i].num == 0) { // mark invalid
                    Aug.mat[i][i].num = big;
                    Aug.mat[i][i].den = big;
                } else Aug.mat[j][k] = Aug.mat[j][k] - Aug.mat[i][k] * Aug.mat[j][i] / Aug.mat[i][i];
            }
        }
    }

    ColumnVector Ans;                              // back substitution phase
    for (int j = N - 1; j >= 0; --j) {               // start from back
        fraction t = 0;
        for (int k = j + 1; k < N; ++k)
            t = t + Aug.mat[j][k] * Ans.vec[k];
        if ((Aug.mat[j][j].num) == 0) { // mark invalid
            Ans.vec[j].num = big;
            Ans.vec[j].den = big;
        } else Ans.vec[j] = (Aug.mat[j][N] - t) / Aug.mat[j][j]; // the answer is here
    }
    return Ans;
}

AugmentedMatrix update(AugmentedMatrix Aug, string s, int idx) {
    bool plus = true, lhs = true;
    int x = 0, y = 0, constant = 0;
    for (int i = 0; i < s.size(); ++i) {
        if (s[i] == '=') {
            lhs = false;
            plus = true;
        }
        if (s[i] == '-' && s[i + 1] == ' ') plus = false;
        if (s[i] == '+') plus = true;
        if (isdigit(s[i]) || s[i] == 'x' || s[i] == 'y') {
            if (i != 0 && s[i - 1] == '-') plus = !plus;
            string digCurr;
            while (isdigit(s[i])) digCurr += s[i++];
            if (s[i] == 'x') {
                if (digCurr.empty()) digCurr = "1";
                if (lhs) x += (plus ? 1 : -1) * stoi(digCurr);
                else x -= (plus ? 1 : -1) * stoi(digCurr);
            } else if (s[i] == 'y') {
                if (digCurr.empty()) digCurr = "1";
                if (lhs) y += (plus ? 1 : -1) * stoi(digCurr);
                else y -= (plus ? 1 : -1) * stoi(digCurr);
            } else {
                if (lhs) constant += (plus ? 1 : -1) * stoi(digCurr);
                else constant -= (plus ? 1 : -1) * stoi(digCurr);
            }
        }
    }
    Aug.mat[idx][0] = fraction(x);
    Aug.mat[idx][1] = fraction(y);
    Aug.mat[idx][2] = fraction(-constant);
    return Aug;
}

// not too hard since easy to test cases using calculator for simultaneous equations
// just tedious ...

int main() {
    //freopen("input.txt", "r", stdin);
    //freopen("output.txt", "w", stdout);
    //freopen("error.txt", "w", stderr);

    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int T;
    cin >> T >> ws;
    while (T--) {
        string s; // we will bring all terms to the left side
        getline(cin, s);
        AugmentedMatrix Aug;
        Aug = update(Aug, s, 0);
        getline(cin, s);
        Aug = update(Aug, s, 1);
        ColumnVector Ans = GaussianElimination(2, Aug);
        for (auto &i: Ans.vec) {
            if (i.num >= big || i.den >= big) {
                cout << "don't know" << endl;
                continue;
            }
            fraction tmpAns = i.reduce();
            if (tmpAns.den == 1) cout << tmpAns.num << endl;
            else cout << tmpAns << endl;
        }
        cout << endl;
        getline(cin, s);
    }


    cerr << "time taken : " << (float) clock() / CLOCKS_PER_SEC << " secs" << endl;
    return 0;
}

// case 1 test many (-) signs
// case 2 test inconsistent const
// case 3 test inconsistent var
// case 4 test nothing
// case 5 test (linearly) dependent - infinite solutions
// case 6 test many (-) signs
// sample input:
//6
//2x + y = 0
//y + -2x - -y = 2
//
//0 = 4
//x = 5
//
//x = 3
//3x = 4
//
//x = 3
//y = -6
//
//2x + 5y = 3
//4x + 10y = 6
//
//2x + -3x - 5y - -3y = -3 - -3
//-y = -6
//
// sample output:
//-1/3
//2/3
//
//don't know
//don't know
//
//don't know
//don't know
//
//3
//-6
//
//don't know
//don't know
//
//-12
//6

